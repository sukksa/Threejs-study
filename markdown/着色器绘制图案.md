# 使用着色器绘制图案

## UV

在创建着色器时，我们需要绘制特定的图案，如星星、圆圈、光透镜、波浪等。虽然可以使用纹理，但绘制形状可以让我们有更多的控制权;我们可以对形状参数进行动画处理，并且没有要加载的纹理。需要在fragment shader中用到uv坐标。

什么是uv坐标？

UV坐标是用来将2D纹理贴图到3D模型表面的坐标系。这里的U和V代表的是2D空间的两个轴，类似于平面中的X和Y，但为了避免与3D空间中的X、Y、Z混淆，所以用U和V来命名。

在Threejs中UV坐标的范围是0到1，覆盖整个纹理图像。原点(0,0)在左下角，而(1,1)在右上角。uv坐标的count取决于material的分段数

如何将uv坐标发送到fragment shader？

fragment shader无法直接访问顶点数据，所以我们需要通过 vertex shader 创建`vUv`变量发送给 fragment shader。

```glsl
// vertex.glsl
varying vec2 vUv;

void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    vUv = uv;
}

// fragment.glsl
varying vec2 vUv;

void main()
{
    // use vUv
    gl_FragColor = vec4(vUv, 1.0, 1.0)
}
```

## 方法

- `1.0 - ...` 反转颜色
- 

## Pattern 1

直接使用 uv 坐标，原点的颜色为`(0.0, 0.0, 1.0, 1.0)`到右上角`(1.0, 1.0, 1.0, 1.0)`的渐变

```glsl
varying vec2 vUv;

void main() {
    gl_FragColor = vec4(vUv, 1.0, 1.0);
}
```

![image-20250422155105545](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422155105545_1745308268.png)

## Pattern 2

同样的使用 uv 坐标，但`b`设置为`0.0`，为`(0.0, 0.0, 0.0, 1.0)`到右上角`(1.0, 1.0, 0.0, 1.0)`的渐变

```glsl
void main() {
    gl_FragColor = vec4(vUv, 0.0, 1.0);
}
```

![image-20250422155853192](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422155853192_1745308737.png)

## Pattern 3

只使用 uv 坐标的`x`值，得到一个在x轴上的黑白渐变。颜色在x轴上y轴上每个点都是`(0.0, 0.0, 0.0, 1.0)`到`(1.0, 1.0, 1.0, 1.0)`变化

```glsl
varying vec2 vUv;

void main()
{
    float strength = vUv.x;
    gl_FragColor = vec4(vec3(strength), 1.0);
}
```

![image-20250422160614995](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422160614995_1745309476.png)

## Pattern 4

和 pattern 3 完全相同，不过应用在y轴上。

```glsl
varying vec2 vUv;

void main()
{
    float strength = vUv.y;
    gl_FragColor = vec4(vec3(strength), 1.0);
}
```

![image-20250422160752938](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422160752938_1745309468.png)

## Pattern 5 (1.0 - ...)

将 pattern 4 的值通过 `1.0 - ...`反转。`(1.0, 1.0, 1.0, 1.0)` 到`(0.0, 0.0, 0.0, 1.0)`变化

```glsl
varying vec2 vUv;

void main()
{
    float strength = 1.0 - vUv.y;
    gl_FragColor = vec4(vec3(strength), 1.0);
}
```

![image-20250422161048251](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422161048251_1745309451.png)

## Pattern 6

将 uv.y 乘以 10，`gl_FragColor`将很快的到达`(1.0, 1.0, 1.0, 1.0)`，后面大于`1.0`也显示白色

```glsl
varying vec2 vUv;

void main()
{
    float strength = vUv.x;
    gl_FragColor = vec4(vec3(strength), 1.0);
}
```

![image-20250422161448435](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422161448435_1745309689.png)

## Pattern 7 mod(...)

通过取模运算 `mod(...)`，重复某一段的变化。

将y的值乘以10.0，模1.0，分为10段，每段都是`(0.0, 0.0, 0.0, 1.0)`到`(1.0, 1.0, 1.0, 1.0)`变化。如果模0.5，最大值为0.5，结果就是`(0.0, 0.0, 0.0, 1.0)`到`(0.5, 0.5, 0.5, 1.0)`

```glsl
varying vec2 vUv;

void main()
{
    float strength = mod(vUv.y * 10.0, 1.0);
    gl_FragColor = vec4(vec3(strength), 1.0);
}
```

![image-20250422162044088](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422162044088_1745310045.png)

## Pattern 8 step(...)

在 pattern 7 的基础上实现斑马条纹，如果颜色在0.5以下，设为0.0；在0.5以上，设置1.0。

可以通过`if()`判断实现，但是会影响性能。

```glsl
varying vec2 vUv;

void main()
{
    float strength = mod(vUv.y * 10.0, 1.0);
    if(strength < 0.5) {
        strength = 0.0;
    } else {
        strength = 1.0;
    } 
    // or
    strength = strength < 0.5 ? 0.0 : 1.0; // 三元运算符
    gl_FragColor = vec4(vec3(strength), 1.0);
}
```

glsl 提供了`step(edge, x)`函数。

- **参数**：`edge` 是阈值，`x` 是输入值。
- **返回值**：若 `x >= edge` 返回 `1.0`，否则返回 `0.0`。

```glsl
varying vec2 vUv;

void main()
{
    float strength = mod(vUv.y * 10.0, 1.0);
    strength = step(0.5, strength); // 超过阈值0.5，返回1.0，否则返回0.0
    gl_FragColor = vec4(vec3(strength), 1.0);
}
```

![image-20250422163923388](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422163923388_1745311164.png)

## Pattern 9

通过调整 `step()`的阈值，更改条纹的粗细。

```glsl
float strength = mod(vUv.y * 10.0, 1.0);
strength = step(0.8, strength);
```

![image-20250422164320581](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422164320581_1745311401.png)

## Pattern 10

将 pattern 9 中修改`vUv.x`，在x轴上分段(竖条纹)

```glsl
float strength = step(0.8, mod(vUv.x * 10.0, 1.0));
```

![image-20250422164543169](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422164543169_1745311544.png)

## Pattern 11 +

将 pattern 9 和 pattern 10 的图案叠加，可以使用`+`取并集

```glsl
float strength = step(0.8, mod(vUv.x * 10.0, 1.0));
strength += step(0.8, mod(vUv.y * 10.0, 1.0)); 
```

![image-20250422164920441](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422164920441_1745311762.png)

## Pattern 12 *

将 pattern 9 和 pattern 10 的图案取相交处，可以使用`*`取交集

```glsl
float strength = step(0.8, mod(vUv.x * 10.0, 1.0));
strength *= step(0.8, mod(vUv.y * 10.0, 1.0)); // 只能看到交点处
```

![image-20250422165050274](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422165050274_1745311851.png)

## Pattern 13

在 pattern 12 上，将x轴上的分段阈值缩小，x轴方向上条纹更粗。然后取交集。

```glsl
float strength = step(0.4, mod(vUv.x * 10.0, 1.0));
strength *= step(0.8, mod(vUv.y * 10.0, 1.0)); 
```

![image-20250422165421888](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422165421888_1745312063.png)

## Pattern 14

将 pattern 13 的图案分别按照水平方向(barX)和竖直方向(barY)实现，然后再取并集。

```glsl
float barX = step(0.4, mod(vUv.x * 10.0, 1.0));
barX *= step(0.8, mod(vUv.y * 10.0, 1.0)); 
float barY = step(0.4, mod(vUv.y * 10.0, 1.0));
barY *= step(0.8, mod(vUv.x * 10.0, 1.0)); 
float strength = barX + barY;
```

![image-20250422170934207](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422170934207_1745312977.png)

## Pattern 15

基于 pattern 14 将 barX 和 barY 分别沿各自的方向偏移0.2，得到 + 图案

```glsl
float barX = step(0.4, mod(vUv.x * 10.0, 1.0));
barX *= step(0.8, mod(vUv.y * 10.0 + 0.2, 1.0));
float barY = step(0.4, mod(vUv.y * 10.0, 1.0));
barY *= step(0.8, mod(vUv.x * 10.0 + 0.2, 1.0));
float strength = barX + barY;
```

![image-20250422171220785](https://raw.githubusercontent.com/sukksa/upgit-images/main/2025/04/image-20250422171220785_1745313141.png)

## Pattern 16

```glsl
float strength = abs(vUv.x - 0.5);
```









glsl 中没有随机数，可以通过传入一个向量，调用下面的方法来的得到一个看起来随机的[0, 1]的数

```glsl
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}
```

$$
f\left(x,y\right)=\frac{0.01}{\sqrt{\left(x-0.5\right)^{2}+\left(y-0.5\right)^{2}}}
$$





glsl 旋转

uv：uv坐标，rotation：旋转角度，mid：旋转中心点

```glsl
#define PI 3.1415926535897932384626433832795 

vec2 rotate(vec2 uv, float rotation, vec2 mid) {
    return vec2(
        cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,
        cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y
    );
}
```

